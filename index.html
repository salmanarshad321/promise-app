<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Promise App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
    <!-- Add FontAwesome for the settings icon -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body class="bg-gray-100">
    <div id="app" class="min-h-screen p-4">
        <div class="max-w-2xl mx-auto bg-white rounded-lg shadow-md p-6">
            <!-- Header and Settings Button -->
            <div class="flex justify-between items-center mb-6">
                <h1 class="text-3xl font-bold text-center text-green-600">Promise</h1>
                <!-- Beautiful Settings Button -->
                <button @click="showSettings = true" class="p-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all flex items-center gap-2">
                    <i class="fas fa-cog"></i> Settings
                </button>
            </div>

            <!-- Score Card -->
            <div class="grid grid-cols-3 gap-4 mb-6 text-center">
                <div class="p-4 bg-green-50 rounded-lg cursor-pointer hover:bg-green-100 transition-all" @click="filter = 'fulfilled'">
                    <p class="text-2xl font-bold text-green-600">{{ fulfilledCount }}</p>
                    <p class="text-sm text-gray-600">Fulfilled</p>
                </div>
                <div class="p-4 bg-red-50 rounded-lg cursor-pointer hover:bg-red-100 transition-all" @click="filter = 'broken'">
                    <p class="text-2xl font-bold text-red-600">{{ brokenCount }}</p>
                    <p class="text-sm text-gray-600">Broken</p>
                </div>
                <div class="p-4 bg-blue-50 rounded-lg cursor-pointer hover:bg-blue-100 transition-all" @click="filter = 'ongoing'">
                    <p class="text-2xl font-bold text-blue-600">{{ ongoingCount }}</p>
                    <p class="text-sm text-gray-600">Ongoing</p>
                </div>
            </div>

            <!-- Filter Pills -->
            <div class="flex gap-2 mb-6">
                <button @click="filter = 'all'" :class="{'bg-green-600 text-white': filter === 'all'}" class="px-4 py-2 rounded-lg border border-green-600 hover:bg-green-600 hover:text-white transition-all">All</button>
                <button @click="filter = 'ongoing'" :class="{'bg-blue-600 text-white': filter === 'ongoing'}" class="px-4 py-2 rounded-lg border border-blue-600 hover:bg-blue-600 hover:text-white transition-all">Ongoing</button>
                <button @click="filter = 'fulfilled'" :class="{'bg-green-600 text-white': filter === 'fulfilled'}" class="px-4 py-2 rounded-lg border border-green-600 hover:bg-green-600 hover:text-white transition-all">Fulfilled</button>
                <button @click="filter = 'broken'" :class="{'bg-red-600 text-white': filter === 'broken'}" class="px-4 py-2 rounded-lg border border-red-600 hover:bg-red-600 hover:text-white transition-all">Broken</button>
            </div>

            <!-- Sorting -->
            <div class="flex gap-2 mb-6">
                <select v-model="sortBy" class="p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">
                    <option value="time">Sort by Time Remaining</option>
                    <option value="created">Sort by Creation Date</option>
                    <option value="alphabetical">Sort Alphabetically</option>
                </select>
            </div>

            <!-- Add Promise Section -->
            <div class="flex flex-col gap-4 mb-6">
                <input v-model="newPromise" type="text" placeholder="Enter your promise" class="p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">
                <div class="flex gap-4">
                    <select v-model="timeUnit" @change="handleTimeUnitChange" class="p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">
                        <option value="minutes">Minutes</option>
                        <option value="hours">Hours</option>
                        <option value="days">Days</option>
                        <option value="datetime">Select Date & Time</option>
                    </select>
                    <input v-if="timeUnit !== 'datetime'" v-model="newTime" type="number" placeholder="Time" class="flex-1 p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">
                    <input v-else ref="datetimePicker" type="text" placeholder="Select Date & Time" class="flex-1 p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">
                </div>
                <button @click="addPromise" class="p-2 bg-green-600 text-white rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500">Add Promise</button>
            </div>

            <!-- Promise List -->
            <ul class="space-y-4">
                <li v-for="(promise, index) in sortedAndFilteredPromises" :key="index" :class="{'border-green-500 bg-green-50': promise.fulfilled, 'border-red-500 bg-red-50': promise.broken}" class="p-4 border rounded-lg">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-lg font-semibold">{{ promise.text }}</span>
                        <span class="text-sm text-gray-600">{{ formatTime(promise.remainingTime) }}</span>
                    </div>
                    <div class="w-full h-2 bg-gray-200 rounded-full overflow-hidden">
                        <div :style="{ width: `${(promise.remainingTime / promise.totalTime) * 100}%`, backgroundColor: getColorBasedOnProgress(promise.remainingTime / promise.totalTime) }" class="h-full transition-all duration-1000"></div>
                    </div>
                    <div class="flex gap-2 mt-3">
                        <button @click="fulfillPromise(index)" :disabled="promise.fulfilled || promise.broken" :class="{'bg-green-600 hover:bg-green-700': !promise.fulfilled && !promise.broken, 'bg-gray-400 cursor-not-allowed': promise.fulfilled || promise.broken}" class="flex-1 p-2 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">
                            {{ promise.fulfilled ? 'Fulfilled!' : promise.broken ? 'Broken!' : 'Fulfill Promise' }}
                        </button>
                        <button @click="deletePromise(index)" class="p-2 bg-red-600 text-white rounded-lg hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500">Delete</button>
                    </div>
                </li>
            </ul>
        </div>

        <!-- Settings Page -->
        <div v-if="showSettings" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
            <div class="bg-white rounded-lg shadow-md p-6 max-w-md w-full">
                <h2 class="text-2xl font-bold text-center text-blue-600 mb-6">Settings</h2>
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Default Time Unit</label>
                        <select v-model="settings.defaultTimeUnit" class="p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">
                            <option value="minutes">Minutes</option>
                            <option value="hours">Hours</option>
                            <option value="days">Days</option>
                            <option value="datetime">Select Date & Time</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Enable Confetti</label>
                        <input type="checkbox" v-model="settings.enableConfetti" class="p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Progress Bar Colors</label>
                        <div class="flex gap-4">
                            <input type="color" v-model="settings.progressColors.green" class="p-1 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">
                            <input type="color" v-model="settings.progressColors.yellow" class="p-1 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">
                            <input type="color" v-model="settings.progressColors.red" class="p-1 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">
                        </div>
                    </div>
                    <button @click="saveSettings" class="mr-2 p-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500">Save Settings</button>
                    <button @click="showSettings = false" class="p-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script>
        const { createApp, ref, computed, onMounted, onUnmounted, watch } = Vue;

        // Repository Pattern for Local Storage
        const PromiseRepository = {
            getPromises() {
                const promises = localStorage.getItem('promises');
                return promises ? JSON.parse(promises) : [];
            },
            savePromises(promises) {
                localStorage.setItem('promises', JSON.stringify(promises));
            }
        };

        const SettingsRepository = {
            getSettings() {
                const settings = localStorage.getItem('settings');
                return settings ? JSON.parse(settings) : {
                    defaultTimeUnit: 'minutes',
                    enableConfetti: true,
                    progressColors: {
                        green: '#16a34a',
                        yellow: '#f59e0b',
                        red: '#dc2626'
                    }
                };
            },
            saveSettings(settings) {
                localStorage.setItem('settings', JSON.stringify(settings));
            }
        };

        createApp({
            setup() {
                const newPromise = ref('');
                const newTime = ref('');
                const timeUnit = ref('minutes');
                const datetimePicker = ref(null);
                const flatpickrInstance = ref(null);
                const promises = ref(PromiseRepository.getPromises());
                const filter = ref('all');
                const sortBy = ref('time');
                const settings = ref(SettingsRepository.getSettings());
                const showSettings = ref(false);

                // Computed Properties
                const fulfilledCount = computed(() => promises.value.filter(p => p.fulfilled).length);
                const brokenCount = computed(() => promises.value.filter(p => p.broken).length);
                const ongoingCount = computed(() => promises.value.filter(p => !p.fulfilled && !p.broken).length);

                const filteredPromises = computed(() => {
                    switch (filter.value) {
                        case 'ongoing':
                            return promises.value.filter(p => !p.fulfilled && !p.broken);
                        case 'fulfilled':
                            return promises.value.filter(p => p.fulfilled);
                        case 'broken':
                            return promises.value.filter(p => p.broken);
                        default:
                            return promises.value;
                    }
                });

                const sortedAndFilteredPromises = computed(() => {
                    const filtered = filteredPromises.value;
                    switch (sortBy.value) {
                        case 'time':
                            return filtered.slice().sort((a, b) => a.remainingTime - b.remainingTime);
                        case 'created':
                            return filtered.slice().sort((a, b) => a.createdAt - b.createdAt);
                        case 'alphabetical':
                            return filtered.slice().sort((a, b) => a.text.localeCompare(b.text));
                        default:
                            return filtered;
                    }
                });

                const handleTimeUnitChange = () => {
                    if (timeUnit.value === 'datetime') {
                        flatpickrInstance.value = flatpickr(datetimePicker.value, {
                            enableTime: true,
                            dateFormat: 'Y-m-d H:i',
                            minDate: 'today',
                            defaultDate: new Date(),
                            onChange: (selectedDates) => {
                                newTime.value = selectedDates[0];
                            }
                        });
                    } else {
                        if (flatpickrInstance.value) {
                            flatpickrInstance.value.destroy();
                            flatpickrInstance.value = null;
                        }
                    }
                };

                const addPromise = () => {
                    if (!newPromise.value) {
                        alert('Please enter a valid promise.');
                        return;
                    }

                    let totalTime = 0;
                    if (timeUnit.value === 'datetime') {
                        const selectedDate = new Date(newTime.value);
                        const now = new Date();
                        if (selectedDate <= now) {
                            alert('Please select a future date and time.');
                            return;
                        }
                        totalTime = Math.floor((selectedDate - now) / 1000); // Convert to seconds
                    } else {
                        const time = parseFloat(newTime.value);
                        if (isNaN(time) || time <= 0) {
                            alert('Please enter a valid time.');
                            return;
                        }
                        switch (timeUnit.value) {
                            case 'minutes':
                                totalTime = time * 60;
                                break;
                            case 'hours':
                                totalTime = time * 3600;
                                break;
                            case 'days':
                                totalTime = time * 86400;
                                break;
                        }
                    }

                    const promise = {
                        text: newPromise.value,
                        totalTime,
                        remainingTime: totalTime,
                        fulfilled: false,
                        broken: false,
                        intervalId: null,
                        createdAt: new Date().getTime()
                    };

                    promise.intervalId = setInterval(() => updateTimer(promise), 1000);
                    promises.value.push(promise);
                    PromiseRepository.savePromises(promises.value);

                    newPromise.value = '';
                    newTime.value = '';
                    if (flatpickrInstance.value) {
                        flatpickrInstance.value.clear();
                    }

                    restoreTimers();
                };

                const updateTimer = (promise) => {
                    if (promise.remainingTime <= 0 && promise.broken === false) {
                        clearInterval(promise.intervalId);
                        promise.broken = true;
                        PromiseRepository.savePromises(promises.value);
                        console.log('Promise broken!');
                        if (settings.value.enableConfetti) {
                            confetti({
                                particleCount: 100,
                                spread: 70,
                                origin: { y: 0.6 },
                                colors: ['#ff0000', '#ff6666', '#ff9999']
                            });
                        }
                        return;
                    } else {
                        PromiseRepository.savePromises(promises.value);
                    }

                    promise.remainingTime--;
                };

                const fulfillPromise = (index) => {
                    const promise = promises.value[index];
                    clearInterval(promise.intervalId);
                    promise.fulfilled = true;
                    PromiseRepository.savePromises(promises.value);
                    if (settings.value.enableConfetti) {
                        confetti({
                            particleCount: 100,
                            spread: 70,
                            origin: { y: 0.6 }
                        });
                    }
                };

                const deletePromise = (index) => {
                    Swal.fire({
                        title: 'Are you sure?',
                        text: "You won't be able to revert this!",
                        icon: 'warning',
                        animation: false,
                        showCancelButton: true,
                        confirmButtonColor: '#3085d6',
                        cancelButtonColor: '#d33',
                        confirmButtonText: 'Yes, delete it!'
                    }).then((result) => {
                        if (result.isConfirmed) {
                            const promise = promises.value[index];
                            if (promise.intervalId) clearInterval(promise.intervalId);
                            promises.value.splice(index, 1);
                            PromiseRepository.savePromises(promises.value);
                        }
                    });
                };

                const getColorBasedOnProgress = (progress) => {
                    if (progress > 0.5) return settings.value.progressColors.green;
                    if (progress > 0.2) return settings.value.progressColors.yellow;
                    return settings.value.progressColors.red;
                };

                const formatTime = (seconds) => {
                    const days = Math.floor(seconds / 86400);
                    const hours = Math.floor((seconds % 86400) / 3600);
                    const mins = Math.floor((seconds % 3600) / 60);
                    const secs = seconds % 60;
                    return `${days > 0 ? `${days}d ` : ''}${hours > 0 ? `${hours}h ` : ''}${mins}m ${secs}s`;
                };

                const restoreTimers = () => {
                    promises.value.forEach(promise => {
                        if (!promise.fulfilled && !promise.broken) {
                            promise.intervalId = setInterval(() => updateTimer(promise), 1000);
                        }
                    });
                };

                const saveSettings = () => {
                    SettingsRepository.saveSettings(settings.value);
                    Swal.fire({
                        title: 'Settings Saved!',
                        icon: 'success',
                        animation: false,
                        timer: 1000,
                        showConfirmButton: false
                    });
                };

                // Restore timers on page load
                onMounted(() => {
                    restoreTimers();
                    timeUnit.value = settings.value.defaultTimeUnit;
                });

                // Cleanup timers on page unload
                onUnmounted(() => {
                    promises.value.forEach(promise => {
                        if (promise.intervalId) clearInterval(promise.intervalId);
                    });
                });

                return {
                    newPromise,
                    newTime,
                    timeUnit,
                    datetimePicker,
                    promises,
                    filter,
                    sortBy,
                    settings,
                    showSettings,
                    fulfilledCount,
                    brokenCount,
                    ongoingCount,
                    sortedAndFilteredPromises,
                    handleTimeUnitChange,
                    addPromise,
                    fulfillPromise,
                    deletePromise,
                    getColorBasedOnProgress,
                    formatTime,
                    saveSettings
                };
            }
        }).mount('#app');
    </script>
</body>
</html>